<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_quality_control: scran::format_filters Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_quality_control
   </div>
   <div id="projectbrief">Compute simple per-cell quality control metrics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescran.html">scran</a></li><li class="navelem"><a class="el" href="namespacescran_1_1format__filters.html">format_filters</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran::format_filters Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Format QC filters for downstream analysis.  
<a href="namespacescran_1_1format__filters.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8558625db78828cc42ff390cb01b7476" id="r_a8558625db78828cc42ff390cb01b7476"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Keep_ &gt; </td></tr>
<tr class="memitem:a8558625db78828cc42ff390cb01b7476"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#a8558625db78828cc42ff390cb01b7476">compute_which</a> (Index_ num, const Keep_ *filter, std::vector&lt; Index_ &gt; &amp;output)</td></tr>
<tr class="separator:a8558625db78828cc42ff390cb01b7476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20527b6752b0d2801b79e8789f873c7c" id="r_a20527b6752b0d2801b79e8789f873c7c"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Keep_ &gt; </td></tr>
<tr class="memitem:a20527b6752b0d2801b79e8789f873c7c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#a20527b6752b0d2801b79e8789f873c7c">compute_which</a> (Index_ num, const Keep_ *filter)</td></tr>
<tr class="separator:a20527b6752b0d2801b79e8789f873c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5c4f474ba88c84f45e99262ab3151d" id="r_adb5c4f474ba88c84f45e99262ab3151d"><td class="memTemplParams" colspan="2">template&lt;typename Keep_ , typename Output_ &gt; </td></tr>
<tr class="memitem:adb5c4f474ba88c84f45e99262ab3151d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#adb5c4f474ba88c84f45e99262ab3151d">compute_combined_keep</a> (size_t num, const std::vector&lt; Keep_ * &gt; &amp;filters, Output_ *output)</td></tr>
<tr class="separator:adb5c4f474ba88c84f45e99262ab3151d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9e49062991fcb0a383ab864b679c3" id="r_a69d9e49062991fcb0a383ab864b679c3"><td class="memTemplParams" colspan="2">template&lt;typename Output_  = uint8_t, typename Keep_  = uint8_t&gt; </td></tr>
<tr class="memitem:a69d9e49062991fcb0a383ab864b679c3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Output_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#a69d9e49062991fcb0a383ab864b679c3">compute_combined_keep</a> (size_t num, const std::vector&lt; const Keep_ * &gt; &amp;filters)</td></tr>
<tr class="separator:a69d9e49062991fcb0a383ab864b679c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27975098c63ee4d138d081bcdaa4d61e" id="r_a27975098c63ee4d138d081bcdaa4d61e"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Keep_ &gt; </td></tr>
<tr class="memitem:a27975098c63ee4d138d081bcdaa4d61e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#a27975098c63ee4d138d081bcdaa4d61e">compute_combined_index</a> (Index_ num, const std::vector&lt; const Keep_ * &gt; &amp;filters, std::vector&lt; Index_ &gt; &amp;output)</td></tr>
<tr class="separator:a27975098c63ee4d138d081bcdaa4d61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36a80dc19559e28ab14a30cce83247" id="r_aea36a80dc19559e28ab14a30cce83247"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Keep_ &gt; </td></tr>
<tr class="memitem:aea36a80dc19559e28ab14a30cce83247"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran_1_1format__filters.html#aea36a80dc19559e28ab14a30cce83247">compute_combined_index</a> (Index_ num, const std::vector&lt; const Keep_ * &gt; &amp;filters)</td></tr>
<tr class="separator:aea36a80dc19559e28ab14a30cce83247"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Format QC filters for downstream analysis. </p>
<p>Here, we convert the filtering vectors produced by <code><a class="el" href="classscran_1_1rna__quality__control_1_1Filters.html#a5f15147ad61823b604e03fc25fcc7934">rna_quality_control::Filters::filter()</a></code> and friends into formats that can be used for downstream analysis. In particular, we want to slice the original feature-by-cell matrix so only the high-quality subset of cells are retained. This is most easily done by using <code><a class="elRef" href="https://tatami-inc.github.io/tatami/namespacetatami.html#a77fad1d2a2553899a7860521d6284f50">tatami::make_DelayedSubset()</a></code> to subset the <code><a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a></code> with the indices of the high-quality cells. For this purpose, we can use <code><a class="el" href="namespacescran_1_1format__filters.html#a8558625db78828cc42ff390cb01b7476">compute_which()</a></code> to convert the boolean filtering vector into a vector of sorted and unique column indices.</p>
<p>When dealing with multiple filters from different modalities (e.g., <code><a class="el" href="classscran_1_1crispr__quality__control_1_1Filters.html#af819567873395d1befb493a542ca586e">crispr_quality_control::Filters::filter()</a></code>, <code><a class="el" href="classscran_1_1adt__quality__control_1_1Filters.html#aca1a528ec6925618e03e350019bf8707">adt_quality_control::Filters::filter()</a></code>), our default strategy is to take the intersection, i.e., we only retain cells that are considered to be high quality in all modalities. This ensures that downstream analyses can be safely performed on each modality in the filtered dataset. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8558625db78828cc42ff390cb01b7476" name="a8558625db78828cc42ff390cb01b7476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8558625db78828cc42ff390cb01b7476">&#9670;&#160;</a></span>compute_which() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Keep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::format_filters::compute_which </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Keep_ *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for array indices. </td></tr>
    <tr><td class="paramname">Keep_</td><td>Boolean type for the filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>Pointer to an array of length <code>num</code>, indicating whether a cell is of high quality. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, a vector of sorted and unique indices of the cells considered to be high quality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20527b6752b0d2801b79e8789f873c7c" name="a20527b6752b0d2801b79e8789f873c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20527b6752b0d2801b79e8789f873c7c">&#9670;&#160;</a></span>compute_which() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Keep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index_ &gt; scran::format_filters::compute_which </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Keep_ *&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for array indices. </td></tr>
    <tr><td class="paramname">Keep_</td><td>Boolean type for each filter modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filter</td><td>Pointer to an array of length <code>num</code>, indicating whether a cell is of high quality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of sorted and unique indices of the cells considered to be high quality. </dd></dl>

</div>
</div>
<a id="adb5c4f474ba88c84f45e99262ab3151d" name="adb5c4f474ba88c84f45e99262ab3151d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5c4f474ba88c84f45e99262ab3151d">&#9670;&#160;</a></span>compute_combined_keep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Keep_ , typename Output_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::format_filters::compute_combined_keep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Keep_ * &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Output_ *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Keep_</td><td>Boolean type for each filter modality. </td></tr>
    <tr><td class="paramname">Output_</td><td>Boolean type for the output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filters</td><td>Vector of pointers to arrays of length <code>num</code>. Each array corresponds to a modality and indicates whether each cell is high quality (truthy) or not (falsey) for that modality. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Pointer to an array of length <code>num</code>. On output, this is filled with truthy values only for cells that are high quality in all modalities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69d9e49062991fcb0a383ab864b679c3" name="a69d9e49062991fcb0a383ab864b679c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d9e49062991fcb0a383ab864b679c3">&#9670;&#160;</a></span>compute_combined_keep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output_  = uint8_t, typename Keep_  = uint8_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Output_ &gt; scran::format_filters::compute_combined_keep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Keep_ * &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Output_</td><td>Boolean type for the output. </td></tr>
    <tr><td class="paramname">Keep_</td><td>Boolean type for each filter modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filters</td><td>Vector of pointers to arrays of length <code>num</code>. Each array corresponds to a modality and indicates whether each cell is high quality (truthy) or not (falsey) for that modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of length <code>num</code>, indicating which cells are high quality in all modalities. </dd></dl>

</div>
</div>
<a id="a27975098c63ee4d138d081bcdaa4d61e" name="a27975098c63ee4d138d081bcdaa4d61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27975098c63ee4d138d081bcdaa4d61e">&#9670;&#160;</a></span>compute_combined_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Keep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran::format_filters::compute_combined_index </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Keep_ * &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for array indices. </td></tr>
    <tr><td class="paramname">Keep_</td><td>Boolean type for each filter modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filters</td><td>Vector of pointers to arrays of length <code>num</code>. Each array corresponds to a modality and indicates whether each cell is high quality (truthy) or not (falsey) for that modality. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, a vector of sorted and unique indices of the cells considered to be high quality in all modalities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea36a80dc19559e28ab14a30cce83247" name="aea36a80dc19559e28ab14a30cce83247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea36a80dc19559e28ab14a30cce83247">&#9670;&#160;</a></span>compute_combined_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Keep_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Index_ &gt; scran::format_filters::compute_combined_index </td>
          <td>(</td>
          <td class="paramtype">Index_&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const Keep_ * &gt; &amp;&#160;</td>
          <td class="paramname"><em>filters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for array indices. </td></tr>
    <tr><td class="paramname">Keep_</td><td>Boolean type for each filter modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of cells in the dataset. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filters</td><td>Vector of pointers to arrays of length <code>num</code>. Each array corresponds to a modality and indicates whether each cell is high quality (truthy) or not (falsey) for that modality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of sorted and unique indices of the cells considered to be high quality in all modalities. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
